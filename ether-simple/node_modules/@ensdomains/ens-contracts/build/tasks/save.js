"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const promises_1 = __importDefault(require("fs/promises"));
const util_1 = require("util");
const config_1 = require("hardhat/config");
const hardhat_config_1 = require("../hardhat.config");
const exec = (0, util_1.promisify)(child_process_1.exec);
(0, config_1.task)('save', 'Saves a specified contract as a deployed contract')
    .addPositionalParam('contract', 'The contract to save')
    .addPositionalParam('block', 'The block number the contract was deployed at')
    .addOptionalParam('fullName', '(Optional) The fully qualified name of the contract (e.g. contracts/resolvers/PublicResolver.sol:PublicResolver)')
    .setAction(async ({ contract, block, fullName, }, hre) => {
    const network = hre.network.name;
    const artifactReference = fullName || contract;
    const artifact = await hre.deployments.getArtifact(artifactReference);
    const archiveName = `${contract}_${network}_${block}`;
    const archivePath = `${hardhat_config_1.archivedDeploymentPath}/${archiveName}.sol`;
    if ((0, fs_1.existsSync)(archivePath)) {
        throw new Error('Archive already exists');
    }
    const newArtifact = {
        ...artifact,
        contractName: archiveName,
        sourceName: archivePath.substring(2),
        commitHash: (await exec('git rev-parse HEAD')).stdout.trim(),
        treeHash: (await exec(`git rev-parse HEAD:${artifact.sourceName}`)).stdout.trim(),
    };
    await promises_1.default.mkdir(archivePath);
    await promises_1.default.writeFile(`${archivePath}/${archiveName}.json`, JSON.stringify(newArtifact, null, 2));
    console.log("Archived contract to '" + archivePath + "'");
});
